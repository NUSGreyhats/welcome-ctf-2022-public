

# This file was *autogenerated* from the file sol.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_8 = Integer(8); _sage_const_20 = Integer(20); _sage_const_2 = Integer(2); _sage_const_128 = Integer(128); _sage_const_4 = Integer(4); _sage_const_7 = Integer(7); _sage_const_11 = Integer(11); _sage_const_29 = Integer(29); _sage_const_30 = Integer(30); _sage_const_49 = Integer(49); _sage_const_50 = Integer(50); _sage_const_59 = Integer(59); _sage_const_72 = Integer(72); _sage_const_88 = Integer(88); _sage_const_127 = Integer(127); _sage_const_9 = Integer(9); _sage_const_45 = Integer(45); _sage_const_60 = Integer(60); _sage_const_68 = Integer(68); _sage_const_86 = Integer(86); _sage_const_99 = Integer(99); _sage_const_100 = Integer(100); _sage_const_111 = Integer(111); _sage_const_8000 = Integer(8000)
from Crypto.Util.number import long_to_bytes
from Crypto.Hash import SHAKE256

class LFSR:
    def __init__(self, seed, taps):
        self.taps = taps
        self.state = seed
        self.length = len(seed)
        
    def next_bit(self):
        new_bit = _sage_const_0 
        for i in range(self.length):
            if i in self.taps:
                new_bit = new_bit + self.state[i]
        res = self.state[_sage_const_0 ]
        self.state = self.state[_sage_const_1 :] + [new_bit]
        return res

def xor(a, b):
    return [((i ^ j) >> k) & _sage_const_1  for i,j in zip(a,b) for k in range(_sage_const_8 )]

def getFlag(key1, key2):
    shake = SHAKE256.new()
    shake.update(long_to_bytes(key1) + long_to_bytes(key2))
    return "greyhats{" + shake.read(_sage_const_20 ).hex() + "}"

c = xor(open("dist/encrypted", 'rb').read(), open("dist/text.txt", 'rb').read())

R1 = PolynomialRing(GF(_sage_const_2 ), 'x', _sage_const_128 )
X = R1.gens()

R2 = PolynomialRing(GF(_sage_const_2 ), 'y', _sage_const_128 )
Y = R2.gens()

tap1 = [_sage_const_0 , _sage_const_4 , _sage_const_7 , _sage_const_11 , _sage_const_29 , _sage_const_30 , _sage_const_49 , _sage_const_50 , _sage_const_59 , _sage_const_72 , _sage_const_88 , _sage_const_127 ]
tap2 = [_sage_const_0 , _sage_const_9 , _sage_const_30 , _sage_const_45 , _sage_const_59 , _sage_const_60 , _sage_const_68 , _sage_const_86 , _sage_const_99 , _sage_const_100 , _sage_const_111 , _sage_const_127 ]
LFSR1 = LFSR([X[i] for i in range(_sage_const_128 )], tap1)
LFSR2 = LFSR([Y[i] for i in range(_sage_const_128 )], tap2)

Mx = []
Vx = []

My = []
Vy = []

count = _sage_const_0 

print(len(c))

for i in range(len(c)):
    f = LFSR1.next_bit()
    g = LFSR2.next_bit()
    if (c[i] == _sage_const_1 ):
        nx = []; ny = []
        Vx.append(_sage_const_0 ); Vy.append(_sage_const_1 )
        for j in range(_sage_const_128 ):
            nx.append(f.coefficient({X[j] : _sage_const_1 }))
            ny.append(g.coefficient({Y[j] : _sage_const_1 }))
        Mx.append(nx)
        My.append(ny)

Mx = Matrix(GF(_sage_const_2 ), Mx)
My = Matrix(GF(_sage_const_2 ), My)
Vx = vector(GF(_sage_const_2 ), Vx)
Vy = vector(GF(_sage_const_2 ), Vy)


conX = Mx.right_kernel().basis()
conY = My.solve_right(Vy)

conX = [int(conX[_sage_const_0 ][i]) for i in range(_sage_const_128 )]
conY = [int(conY[i]) for i in range(_sage_const_128 )]

for i in range(_sage_const_8000 ):
    t1 = conX[-_sage_const_1 ]
    for j in tap1[_sage_const_1 :]:
        t1 = t1 ^ conX[j - _sage_const_1 ]
    conX = [t1] + conX[:-_sage_const_1 ]

    t2 = conY[-_sage_const_1 ]
    for j in tap2[_sage_const_1 :]:
        t2 = t2 ^ conY[j - _sage_const_1 ]
    conY = [t2] + conY[:-_sage_const_1 ]

seed1 = _sage_const_0 
seed2 = _sage_const_0 
for i in range(_sage_const_128 ):
    seed1 += conX[i] << i
    seed2 += conY[i] << i

print(getFlag(seed1, seed2))

