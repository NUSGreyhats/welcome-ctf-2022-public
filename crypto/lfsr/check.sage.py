

# This file was *autogenerated* from the file check.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_128 = Integer(128); _sage_const_2 = Integer(2); _sage_const_4 = Integer(4); _sage_const_29 = Integer(29); _sage_const_30 = Integer(30); _sage_const_72 = Integer(72); _sage_const_88 = Integer(88); _sage_const_127 = Integer(127); _sage_const_9 = Integer(9); _sage_const_45 = Integer(45); _sage_const_59 = Integer(59); _sage_const_100 = Integer(100); _sage_const_111 = Integer(111); _sage_const_1500 = Integer(1500)
from secrets import randbits

class LFSR:
    def __init__(self, seed, taps):
        self.taps = taps
        self.state = seed
        self.length = len(seed)
        
    def next_bit(self):
        new_bit = _sage_const_0 
        for i in range(self.length):
            if i in self.taps:
                new_bit = new_bit + self.state[i]
        res = self.state[_sage_const_0 ]
        self.state = self.state[_sage_const_1 :] + [new_bit]
        return res

class LFSRO:
    def __init__(self, seed_num, taps):
        seed = [(seed_num >> i) & _sage_const_1  for i in range(_sage_const_128 )]
        self.taps = taps
        self.state = seed
        self.length = len(seed)

    def next_bit(self):
        new_bit = _sage_const_0 
        for i in range(self.length):
            if i in self.taps:
                new_bit = new_bit ^ self.state[i]
        res = self.state[_sage_const_0 ]
        self.state = self.state[_sage_const_1 :] + [new_bit]
        return res



R1 = PolynomialRing(GF(_sage_const_2 ), 'x', _sage_const_128 )
X = R1.gens()

R2 = PolynomialRing(GF(_sage_const_2 ), 'y', _sage_const_128 )
Y = R2.gens()

LFSR1 = LFSR([X[i] for i in range(_sage_const_128 )], [_sage_const_0 , _sage_const_4 , _sage_const_29 , _sage_const_30 , _sage_const_72 , _sage_const_88 , _sage_const_127 ])
LFSR2 = LFSR([Y[i] for i in range(_sage_const_128 )], [_sage_const_0 , _sage_const_9 , _sage_const_45 , _sage_const_59 , _sage_const_100 , _sage_const_111 , _sage_const_127 ])

LFSRO1 = LFSRO(randbits(_sage_const_128 ), [_sage_const_0 , _sage_const_4 , _sage_const_29 , _sage_const_30 , _sage_const_72 , _sage_const_88 , _sage_const_127 ])
LFSRO2 = LFSRO(randbits(_sage_const_128 ), [_sage_const_0 , _sage_const_9 , _sage_const_45 , _sage_const_59 , _sage_const_100 , _sage_const_111 , _sage_const_127 ])

def get_random_bit():
    a = LFSRO1.next_bit()
    b = LFSRO2.next_bit()
    return ((a ** b) & (a | b)) ** (a ** (a & b))

Mx = []
Vx = []

My = []
Vy = []

count = _sage_const_0 

for i in range(_sage_const_1500 ):
    f = LFSR1.next_bit()
    g = LFSR2.next_bit()
    if (get_random_bit() == _sage_const_1 ):
        nx = []; ny = []
        Vx.append(_sage_const_0 ); Vy.append(_sage_const_1 )
        for j in range(_sage_const_128 ):
            nx.append(f.coefficient({X[j] : _sage_const_1 }))
            ny.append(g.coefficient({Y[j] : _sage_const_1 }))
        Mx.append(nx)
        My.append(ny)

Mx = Matrix(GF(_sage_const_2 ), Mx)
My = Matrix(GF(_sage_const_2 ), My)
Vx = vector(GF(_sage_const_2 ), Vx)
Vy = vector(GF(_sage_const_2 ), Vy)

print(Mx.rref())
# print(Mx.solve_right(Vx))

